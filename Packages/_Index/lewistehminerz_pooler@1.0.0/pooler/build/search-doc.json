[{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"GitHub​","type":1,"pageTitle":"Installation","url":"docs/Installation#github","content":"You can grab the latest release from GitHub. Just download Pooler.lua and either save it into your project (for Rojo, as an example) or add it in Roblox Studio. "},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"docs/Installation#wally","content":"pooler = &quot;lewistehminerz/pooler@1.0.0&quot; "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"Getting Started API DocsInstallationUsageOptimization","keywords":""},{"title":"Pooler","type":0,"sectionRef":"#","url":"api/Pooler","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Pooler","url":"api/Pooler#types","content":" "},{"title":"GetMethod​","type":1,"pageTitle":"Pooler","url":"api/Pooler#GetMethod","content":"&lt;/&gt; type GetMethod = &quot;sequential&quot; | &quot;random&quot; The method that this Pooler should use to retrieve instances. sequential will retrieve them in an ascending order (item 1 -&gt; item n) whilst random will retrieve instances randomly.  "},{"title":"ReturnMethod​","type":1,"pageTitle":"Pooler","url":"api/Pooler#ReturnMethod","content":"&lt;/&gt; type ReturnMethod = &quot;nilParent&quot; | &quot;cframe&quot; The method that this Pooler should use to return instances. nilParent will set the instance's parent to nil and leave all other properties intact whilst cframe will set the CFrame of the instance to a very long distance away, which is faster for BaseParts and Models with PrimaryPart set. cframe, as such, is only supported if you're pooling BaseParts or Models.  "},{"title":"Options​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Options","content":"&lt;/&gt; interface Options { size: number?-- The number of objects to initialise this pool with. getMethod: GetMethod?-- The get method to use. returnMethod: ReturnMethod?-- The return method to use. unsafe: boolean?-- Whether or not the Pooler should skip safety checks. This pretty much means that you're on your own when it comes to doing things properly, but it increases performance. exhaustion: boolean?-- Whether or not the pool can be exhausted. When enabled, instances will be removed from the internal pool table and you will have to return them yourself to add them back. } An object that describes any extra options you want to pass when creating a Pooler. All options are not required. "},{"title":"Functions​","type":1,"pageTitle":"Pooler","url":"api/Pooler#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Pooler","url":"api/Pooler#new","content":"Constructor &lt;/&gt; Pooler.new( instanceTemplate: T,-- The instance that this Pooler should base its pooled objects on. opts: Options?-- Any extra options you want to pass. ) → Pooler&lt;T&gt;-- A Pooler instance. Creates a new Pooler instance. local pool = Pooler.new(Instance.new(&quot;Part&quot;))  "},{"title":"Errors","type":1,"pageTitle":"Pooler","url":"api/Pooler##","content":"Type\tDescription&quot;cannot create Pooler without an instance template&quot;\tOccurs when you're attempting to create a Pooler without a template. &quot;cannot create Pooler with cframe return method if instance template is not a BasePart or Model&quot;\tOccurs when trying to use the `cframe` ReturnMethod when your template isn't a BasePart or a Model. &quot;cannot create Pooler with cframe return method if instance template is a Model and it has no PrimaryPart&quot;\tOccurs when trying to use the `cframe` ReturnMethod when your template is a Model and it has no PrimaryPart. &quot;cannot use random getMethod with exhaustion enabled&quot;\tOccurs when you're trying to use the `random` GetMethod with `exhaustion` enabled. `random` is not a valid GetMethod since it might retrieve a nil value.  "},{"title":"Get​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Get","content":"&lt;/&gt; Pooler:Get() → T-- An instance. Gets an instance from the pool. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) local instance = pool:Get()  "},{"title":"Errors","type":1,"pageTitle":"Pooler","url":"api/Pooler##","content":"Type\tDescription&quot;attempt to use destroyed Pooler instance&quot;\tOccurs when this Pooler has been destroyed and you are trying to call methods on it. &quot;pool exhausted&quot;\tOccurs when the pool has been exhausted of all of it's instances and exhaustion is enabled.  "},{"title":"Wait​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Pooler:Wait() → T-- An instance. Gets an instance from the pool. If the pool is exhausted, it will wait until an instance is available before returning. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) local instance = pool:Wait()  "},{"title":"Errors","type":1,"pageTitle":"Pooler","url":"api/Pooler##","content":"Type\tDescription&quot;attempt to use destroyed Pooler instance&quot;\tOccurs when this Pooler has been destroyed and you are trying to call methods on it.  "},{"title":"Return​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Return","content":"&lt;/&gt; Pooler:Return( instance: T-- The instance to return. ) → () Returns an instance to the pool. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) local instance = pool:Get() pool:Return(instance)  "},{"title":"Errors","type":1,"pageTitle":"Pooler","url":"api/Pooler##","content":"Type\tDescription&quot;attempt to use destroyed Pooler instance&quot;\tOccurs when this Pooler has been destroyed and you are trying to call methods on it. &quot;attempt to return instance not part of this pool&quot;\tOccurs when you attempt to return an instance that wasn't a part of this pool to begin with. &quot;instance is not a BasePart or Model but it's using the cframe return method&quot;\tOccurs when the instance you're returning is not a BasePart or a Model, but you're somehow using the CFrame return method. If safety is enabled and you haven't been tampering with the internals, this is almost always a bug and should be reported.  "},{"title":"Size​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Size","content":"&lt;/&gt; Pooler:Size() → number-- The size of the pool. Get the current size of the pool. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) local size = pool:Size()   "},{"title":"Resize​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Resize","content":"&lt;/&gt; Pooler:Resize( newSize: number-- The new size the pool should be. ) → () Resizes the pool. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) pool:Resize(1000)  "},{"title":"Errors","type":1,"pageTitle":"Pooler","url":"api/Pooler##","content":"Type\tDescription&quot;attempt to use destroyed Pooler instance&quot;\tOccurs when this Pooler has been destroyed and you are trying to call methods on it.  "},{"title":"Destroy​","type":1,"pageTitle":"Pooler","url":"api/Pooler#Destroy","content":"&lt;/&gt; Pooler:Destroy() → () Destroys this Pooler and destroys all instances associated with the pool. local pool = Pooler.new(Instance.new(&quot;Part&quot;)) pool:Destroy()  "},{"title":"Usage","type":0,"sectionRef":"#","url":"docs/Usage","content":"Usage Pooler is a dead simple library to use. Your existing code might look like this: local Debris = game:GetService(&quot;Debris&quot;) local template = Instance.new(&quot;Part&quot;) template.Anchored = false template.Material = Enum.Material.Neon template.BrickColor = BrickColor.Green() while true do local instance = template:Clone() instance.Parent = workspace Debris:AddItem(instance, 3) task.wait() end Copy This is obviously a very bizarre use case, but let's roll with it. Converting this to Pooler is quite an easy task. Add Pooler to your script: local Pooler = require(script.Parent.Pooler) -- or wherever your copy might be... Copy Create your instance pool: local pool = Pooler.new(template) Copy Swap out your :Clone() and :AddItem() calls for the Pooler equivalents: while true do local instance = pool:Get() instance.Parent = workspace task.delay(3, function() pool:Return(instance) end) task.wait() end Copy Returning is optional Here, we use pool:Return(instance) to make sure our instances go back to the pool after we're done. However, if the pool is exhausted, Pooler will automatically return the instance it retrieves for you. In the standard sequential mode, it will return the oldest instances first. Easy, right?","keywords":""},{"title":"Optimization","type":0,"sectionRef":"#","url":"docs/Optimization","content":"","keywords":""},{"title":"Scaling up the pool​","type":1,"pageTitle":"Optimization","url":"docs/Optimization#scaling-up-the-pool","content":"The default size of the pool is 100. Depending on your use case, this will be way too little instances. Pass size = &lt;n&gt; to increase the default pool size. "},{"title":"Dynamic scaling​","type":1,"pageTitle":"Optimization","url":"docs/Optimization#dynamic-scaling","content":"Pooler supports a form of dynamic scaling by using pool:Resize(newSize). This will automatically add or remove instances depending on on the new size. You can also get the current size by using pool:Size() to introduce some automatic scaling based on pool usage. "},{"title":"Using a different return method​","type":1,"pageTitle":"Optimization","url":"docs/Optimization#using-a-different-return-method","content":"If you're using BaseParts or Models with PrimaryPart set, then you should be using the cframe return method instead of the defaultnilParent return method. This will cause the parts or models to be CFramed away outside of the map rather than modifying the parent, which is a much more costly operation. "},{"title":"Disabling safety​","type":1,"pageTitle":"Optimization","url":"docs/Optimization#disabling-safety","content":"The largest amount of time is dedicated to safety. If you know that your calls to Pooler are correct, you don't need to bother. When creating your pool, pass unsafe = true as an option to disable safety. This will speed up your pool drastically at the cost of being able to create some weird bugs if you don't check your code properly. "}]